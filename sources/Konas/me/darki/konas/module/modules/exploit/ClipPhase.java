package me.darki.konas.module.modules.exploit;

import cookiedragon.eventsystem.Subscriber;
import me.darki.konas.event.events.PacketEvent;
import me.darki.konas.event.events.PlayerMoveEvent;
import me.darki.konas.event.events.PlayerUpdateEvent;
import me.darki.konas.mixin.mixins.ISPacketPlayerPosLook;
import me.darki.konas.module.Module;
import me.darki.konas.setting.Setting;
import me.darki.konas.util.client.PlayerUtils;
import me.darki.konas.util.client.TimeVec3d;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;

import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import static me.darki.konas.module.modules.exploit.PacketFly.randomLimitedVertical;

public class ClipPhase extends Module {
    private static Setting<Float> speed = new Setting<>("Speed", 1f, 2f, 0.1f, 0.05f);

    public ClipPhase() {
        super("ClipPhase", Category.EXPLOIT);
    }

    private int teleportId = 0;

    private ArrayList<CPacketPlayer> packets = new ArrayList<>();
    private Map<Integer, TimeVec3d> posLooks = new ConcurrentHashMap<>();

    double speedX = 0;
    double speedY = 0;
    double speedZ = 0;

    @Subscriber
    public void onPlayerUpdate(PlayerUpdateEvent event) {
        if (mc.player == null || mc.world == null) {
            toggle();
            return;
        }

        if (mc.player.ticksExisted % 20 == 0) {
            cleanPosLooks();
        }

        mc.player.setVelocity(0.0D, 0.0D, 0.0D);

        if (teleportId <= 0) {
            CPacketPlayer startingOutOfBoundsPos = new CPacketPlayer.Position(mc.player.posX, mc.player.posY + randomLimitedVertical(), mc.player.posZ, mc.player.onGround);
            packets.add(startingOutOfBoundsPos);
            mc.player.connection.sendPacket(startingOutOfBoundsPos);
        }

        double[] dir = PlayerUtils.directionSpeed(speed.getValue());

        speedX = dir[0];
        speedY = 0;
        speedZ = dir[1];

        Vec3d newPos = new Vec3d(mc.player.posX + speedX, mc.player.posY, mc.player.posZ + speedZ);
        Vec3d blockCenter = new Vec3d(Math.floor(mc.player.posX), Math.floor(mc.player.posY), Math.floor(mc.player.posZ)).add(0.5, 0, 0.5);

        Vec3d min = newPos.subtract(0.3, 0, 0.3);
        Vec3d max = newPos.add(0.3, 0, 0.3);

        Vec3i minI = new Vec3i(Math.floor(min.x), Math.floor(min.y), Math.floor(min.z));
        Vec3i maxI = new Vec3i(Math.floor(max.x), Math.floor(max.y), Math.floor(max.z));

        if (!minI.equals(maxI) && newPos.distanceTo(blockCenter) > mc.player.getPositionVector().distanceTo(blockCenter)) {
            dir = PlayerUtils.directionSpeed(0.062);
            speedX = dir[0];
            speedY = 0;
            speedZ = dir[1];
            CPacketPlayer move = new CPacketPlayer.Position(mc.player.posX + speedX, mc.player.posY + speedY, mc.player.posZ + speedZ, mc.player.onGround);
            packets.add(move);
            mc.player.connection.sendPacket(move);
            CPacketPlayer extremeMove = new CPacketPlayer.Position(mc.player.posX + speedX, mc.player.posY + randomLimitedVertical(), mc.player.posZ + speedZ, mc.player.onGround);
            packets.add(extremeMove);
            mc.player.connection.sendPacket(extremeMove);
            teleportId++;
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportId));
            posLooks.put(teleportId, new TimeVec3d(mc.player.posX, mc.player.posY, mc.player.posZ, System.currentTimeMillis()));
        } else {
            CPacketPlayer move = new CPacketPlayer.Position(newPos.x, newPos.y, newPos.z, mc.player.onGround);
            packets.add(move);
            mc.player.connection.sendPacket(move);
        }

        mc.player.setVelocity(speedX, speedY, speedZ);
    }

    @Subscriber
    public void onPlayerMove(PlayerMoveEvent event) {
        event.setX(speedX);
        event.setY(speedY);
        event.setZ(speedZ);
    }

    private boolean checkCollisionBox() {
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox()).isEmpty();
    }

    @Subscriber
    public void onSend(PacketEvent.Send event) {
        if (event.getPacket() instanceof CPacketPlayer && !(event.getPacket() instanceof CPacketPlayer.Position)) {
            event.cancel();
        }
        if (event.getPacket() instanceof CPacketPlayer) {
            CPacketPlayer packet = (CPacketPlayer) event.getPacket();
            if (this.packets.contains(packet)) {
                this.packets.remove(packet);
                return;
            }
            event.cancel();
        }
    }

    @Subscriber
    public void onReceive(PacketEvent.Receive event) {
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            if (!(mc.currentScreen instanceof GuiDownloadTerrain)) {
                SPacketPlayerPosLook packet = (SPacketPlayerPosLook) event.getPacket();
                if (mc.player.isEntityAlive()) {
                    if (this.teleportId <= 0) {
                        this.teleportId = ((SPacketPlayerPosLook) event.getPacket()).getTeleportId();
                    } else {
                        if (mc.world.isBlockLoaded(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ), false)) {
                            if (posLooks.containsKey(packet.getTeleportId())) {
                                TimeVec3d vec = posLooks.get(packet.getTeleportId());
                                if (vec.x == packet.getX() && vec.y == packet.getY() && vec.z == packet.getZ()) {
                                    posLooks.remove(packet.getTeleportId());
                                    event.setCancelled(true);
                                    return;
                                }
                            }
                        }
                    }
                }
                ((ISPacketPlayerPosLook) packet).setYaw(mc.player.rotationYaw);
                ((ISPacketPlayerPosLook) packet).setPitch(mc.player.rotationPitch);
                packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.X_ROT);
                packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.Y_ROT);
                teleportId = packet.getTeleportId();
            } else {
                teleportId = 0;
            }
        }

    }

    private void cleanPosLooks() {
        posLooks.forEach((tp, timeVec3d) -> {
            if (System.currentTimeMillis() - timeVec3d.getTime() > TimeUnit.SECONDS.toMillis(30L)) {
                posLooks.remove(tp);
            }
        });
    }

    public void onEnable() {
        packets.clear();
        posLooks.clear();
        teleportId = -1;
    }
}
