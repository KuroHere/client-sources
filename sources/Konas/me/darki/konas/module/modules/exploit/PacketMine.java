package me.darki.konas.module.modules.exploit;

import cookiedragon.eventsystem.Subscriber;
import me.darki.konas.event.events.DamageBlockEvent;
import me.darki.konas.event.events.Render3DEvent;
import me.darki.konas.event.events.UpdateWalkingPlayerEvent;
import me.darki.konas.module.Module;
import me.darki.konas.module.modules.player.AutoTool;
import me.darki.konas.setting.ColorSetting;
import me.darki.konas.setting.Setting;
import me.darki.konas.util.KonasGlobals;
import me.darki.konas.util.interaction.InteractionUtil;
import me.darki.konas.util.render.FaceMasks;
import me.darki.konas.util.render.TessellatorUtil;
import me.darki.konas.util.timer.Timer;
import net.minecraft.block.state.IBlockState;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

import java.awt.*;
import java.util.LinkedList;

public class PacketMine extends Module {

    private static Setting<Float> delay = new Setting<>("Delay", 0.1F, 5F, 0F, 0.1F);
    private static Setting<Float> reach = new Setting<>("Reach", 4.2F, 6F, 1F, 0.1F);
    private static Setting<Boolean> rotate = new Setting<>("Rotate", false);
    private static Setting<Boolean> swap = new Setting<>("AutoSwap", false);
    private static Setting<Boolean> queue = new Setting<>("Queue", false);
    private static Setting<Boolean> render = new Setting<>("Render", false);
    private Setting<ColorSetting> queueColor = new Setting<>("Queue", new ColorSetting(0x550000FF)).withVisibility(render::getValue);
    private Setting<ColorSetting> queueLineColor = new Setting<>("QueueOutline", new ColorSetting(Color.BLUE.hashCode())).withVisibility(render::getValue);
    private Setting<ColorSetting> miningColor = new Setting<>("Mining", new ColorSetting(0x55FF0000)).withVisibility(render::getValue);
    private Setting<ColorSetting> miningLineColor = new Setting<>("MiningOutline", new ColorSetting(Color.RED.hashCode())).withVisibility(render::getValue);
    private Setting<ColorSetting> readyColor = new Setting<>("Ready", new ColorSetting(0x5500FF00)).withVisibility(render::getValue);
    private Setting<ColorSetting> readyLineColor = new Setting<>("ReadyOutline", new ColorSetting(Color.GREEN.hashCode())).withVisibility(render::getValue);
    private final Setting<Float> width = new Setting<>("Width", 1.5F, 10F, 0F, 0.1F).withVisibility(render::getValue);

    public PacketMine() {
        super("PacketMine", Category.EXPLOIT, "ServerSideMine");
    }

    private float curBlockDamage;
    private int originalSlot;
    private BlockInfo currentBlock;
    private Timer timer = new Timer();

    private Runnable postAction;

    private final LinkedList<BlockInfo> blocks = new LinkedList<>();

    public void onEnable() {
        blocks.clear();
        currentBlock = null;
        curBlockDamage = 0F;
        postAction = null;
        originalSlot = -1;
    }

    @Subscriber
    public void onRender3D(Render3DEvent event) {
        LinkedList<BlockInfo> renderBlocks = (LinkedList<BlockInfo>) blocks.clone();
        if (currentBlock != null) {
            renderBlocks.add(currentBlock);
        }
        while (!renderBlocks.isEmpty()) {
            BlockInfo renderBlock = renderBlocks.poll();
            AxisAlignedBB axisAlignedBB = mc.world.getBlockState(renderBlock.getPos()).getBoundingBox(mc.world, renderBlock.getPos()).offset(renderBlock.getPos());
            if (axisAlignedBB == null) continue;
            TessellatorUtil.prepare();
            TessellatorUtil.drawBox(axisAlignedBB, true, 1, getColor(renderBlock), FaceMasks.Quad.ALL);
            TessellatorUtil.drawBoundingBox(axisAlignedBB, width.getValue(), getOutlineColor(renderBlock));
            TessellatorUtil.release();
        }
    }

    @Subscriber
    public void onMine(DamageBlockEvent event) {
        event.cancel();
        if (event.getPos() == null || !canBreak(event.getPos())) return;

        BlockInfo info = new BlockInfo(event.getPos(), event.getFace());

        if (!blocks.contains(info) && (queue.getValue() || (blocks.isEmpty() && currentBlock == null))) {
            blocks.add(info);
        }
    }

    @Subscriber
    public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent.Pre event) {

        if (!InteractionUtil.canPlaceNormally(rotate.getValue())) return;

        if (currentBlock != null) {
            if (mc.world.getBlockState(currentBlock.getPos()).getBlock().equals(currentBlock.getStartState().getBlock()) &&
                    mc.player.getPositionEyes(1F).distanceTo(new Vec3d(currentBlock.getPos()).add(new Vec3d(currentBlock.getFacing().getDirectionVec()).scale(0.5D))) <= reach.getValue()) {
                updateProgress();
                if (swap.getValue() && curBlockDamage >= 1F && originalSlot == -1) {
                    int bestSlot = AutoTool.findBestTool(currentBlock.getPos());
                    if (bestSlot != -1 && bestSlot != mc.player.inventory.currentItem) {
                        mc.player.connection.sendPacket(new CPacketHeldItemChange(bestSlot));
                        originalSlot = bestSlot;
                    }
                }
            } else {
                currentBlock = null;
                if (originalSlot != -1) {
                    mc.player.connection.sendPacket(new CPacketHeldItemChange(originalSlot));
                    originalSlot = -1;
                }
            }

        } else if (!blocks.isEmpty()) {

            BlockInfo info = blocks.peek();

            if (mc.world.getBlockState(info.getPos()).getBlock().equals(info.getStartState().getBlock()) &&
                    mc.player.getPositionEyes(1F).distanceTo(new Vec3d(info.getPos()).add(new Vec3d(info.getFacing().getDirectionVec()).scale(0.5D))) <= reach.getValue()) {
                blocks.poll();
                currentBlock = info;
                curBlockDamage = 0F;
                timer.reset();
                postAction = () -> {
                    if(currentBlock != null) {
                        mc.player.swingArm(EnumHand.MAIN_HAND);
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, currentBlock.getPos(), currentBlock.getFacing()));
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentBlock.getPos(), currentBlock.getFacing()));
                    }
                };
                updateProgress();
            } else {
                blocks.poll();
            }

        }

        if (rotate.getValue() && currentBlock != null) {
            KonasGlobals.INSTANCE.rotationManager.lookAtVec3d(new Vec3d(currentBlock.getPos()).add(new Vec3d(currentBlock.getFacing().getDirectionVec()).scale(0.5D)));

        }

    }

    @Subscriber
    public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent.Post event) {

        if (postAction != null && timer.hasPassed(delay.getValue() * 50F)) {
            postAction.run();
            postAction = null;
        }

    }

    private void updateProgress() {

        if (curBlockDamage >= 1F) {
            return;
        }

        IBlockState state = currentBlock.getStartState();
        int bestSlot = AutoTool.findBestTool(currentBlock.getPos());

        if (bestSlot == -1) {
            bestSlot = mc.player.inventory.currentItem;
        }

        int prevItem = mc.player.inventory.currentItem;

        mc.player.inventory.currentItem = bestSlot;
        curBlockDamage += state.getPlayerRelativeBlockHardness(mc.player, mc.world, currentBlock.getPos());
        mc.player.inventory.currentItem = prevItem;
    }

    private boolean canBreak(BlockPos pos) {
        try {
            final IBlockState blockState = mc.world.getBlockState(pos);
            return blockState.getBlockHardness(mc.world, pos) != -1;
        } catch (NullPointerException e) {
            return false;
        }
    }

    private ColorSetting getColor(BlockInfo info) {
        if (info.equals(currentBlock)) {
            if (curBlockDamage >= 1F) {
                return readyColor.getValue();
            } else {
                return miningColor.getValue();
            }
        } else {
            return queueColor.getValue();
        }
    }

    private ColorSetting getOutlineColor(BlockInfo info) {
        if (info.equals(currentBlock)) {
            if (curBlockDamage >= 1F) {
                return readyLineColor.getValue();
            } else {
                return miningLineColor.getValue();
            }
        } else {
            return queueLineColor.getValue();
        }
    }

    private static class BlockInfo {

        protected final BlockPos pos;
        protected final EnumFacing facing;
        protected final IBlockState startState;

        public BlockInfo(BlockPos pos, EnumFacing facing) {
            this.pos = pos;
            this.facing = facing;
            this.startState = mc.world.getBlockState(pos);
        }

        public BlockPos getPos() {
            return pos;
        }

        public EnumFacing getFacing() {
            return facing;
        }

        public IBlockState getStartState() {
            return startState;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            BlockInfo blockInfo = (BlockInfo) o;
            return pos.equals(blockInfo.pos);
        }

    }

}
