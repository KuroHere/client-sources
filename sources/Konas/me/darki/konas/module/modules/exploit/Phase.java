package me.darki.konas.module.modules.exploit;

import cookiedragon.eventsystem.Subscriber;
import me.darki.konas.event.events.AddCollisionToBoxListEvent;
import me.darki.konas.event.events.BlockPushOutEvent;
import me.darki.konas.event.events.PlayerUpdateEvent;
import me.darki.konas.event.events.UpdateWalkingPlayerEvent;
import me.darki.konas.module.Module;
import me.darki.konas.setting.Setting;
import me.darki.konas.util.client.PlayerUtils;
import net.minecraft.entity.item.EntityBoat;
import net.minecraft.network.play.client.CPacketPlayer;

public class Phase extends Module {
    private static Setting<Mode> mode = new Setting<>("Mode", Mode.SAND);

    private static Setting<Boolean> noVoid = new Setting<>("NoVoid", true);
    private static Setting<Boolean> autoClip = new Setting<>("AutoClip", false);
    private static Setting<Double> distance = new Setting<>("Distance", 6D, 10D, 0.1, 0.1);

    private enum Mode {
        SAND, NOCLIP
    }

    public Phase() {
        super("Phase", "Non Full-Block Phase", Category.EXPLOIT, "DoorClip", "NoClip");
    }

    @Subscriber
    public void onAddCollisionBoxToList(AddCollisionToBoxListEvent event) {
        if(mc.player == null || mc.world == null) return;
        if (mode.getValue() == Mode.SAND) {
            if (mc.player.getRidingEntity() != null && event.getEntity() == mc.player.getRidingEntity()) {
                if (mc.gameSettings.keyBindSprint.isKeyDown() && noVoid.getValue()) {
                    event.setCancelled(true);
                } else {
                    if (mc.gameSettings.keyBindJump.isKeyDown() && event.getPos().getY() >= mc.player.getRidingEntity().posY) {
                        event.setCancelled(true);
                    }
                    if (event.getPos().getY() >= mc.player.getRidingEntity().posY) {
                        event.setCancelled(true);
                    }
                }
            }
        } else {
            if (event.getEntity() == mc.player || mc.player.getRidingEntity() != null && event.getEntity() == mc.player.getRidingEntity()) {
                event.setCancelled(true);
            }
        }
    }

    @Subscriber
    public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent.Pre event) {
        setExtraInfo(mode.getValue().name());
        if (mode.getValue() == Mode.NOCLIP) {
            mc.player.setVelocity(0, 0, 0);
            if (mc.gameSettings.keyBindForward.isKeyDown() || mc.gameSettings.keyBindBack.isKeyDown() || mc.gameSettings.keyBindLeft.isKeyDown() || mc.gameSettings.keyBindRight.isKeyDown()) {
                final double[] speed = PlayerUtils.directionSpeed(0.06f);
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + speed[0], mc.player.posY, mc.player.posZ + speed[1], mc.player.onGround));
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, 0, mc.player.posZ, mc.player.onGround));
            }
            if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (distance.getValue() / 1000), mc.player.posZ, mc.player.onGround));
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, 0, mc.player.posZ, mc.player.onGround));
            }

            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + (distance.getValue() / 1000), mc.player.posZ, mc.player.onGround));
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, 0, mc.player.posZ, mc.player.onGround));
            }
        }
    }

    @Subscriber
    public void onBlockPushOut(BlockPushOutEvent event) {
        event.setCancelled(true);
    }

    @Subscriber
    public void onUpdate(PlayerUpdateEvent event) {
        if (mode.getValue() == Mode.SAND) {
            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                if (mc.player.getRidingEntity() != null && mc.player.getRidingEntity() instanceof EntityBoat) {
                    final EntityBoat boat = (EntityBoat) mc.player.getRidingEntity();
                    if (boat.onGround) {
                        boat.motionY = 0.42f;
                    }
                }
            }
        }

    }

    public void onEnable() {
        if (autoClip.getValue()) {
            if (mc.player != null && mc.world != null) {
                double cos = Math.cos(Math.toRadians(mc.player.rotationYaw + 90.0f));
                double sin = Math.sin(Math.toRadians(mc.player.rotationYaw + 90.0f));
                mc.player.setPosition(mc.player.posX + (1.0 * (distance.getValue() / 1000) * cos + 0.0 * (distance.getValue() / 1000) * sin), mc.player.posY, mc.player.posZ + (1.0 * (distance.getValue() / 1000) * sin - 0.0 * (distance.getValue() / 1000) * cos));
            }
        }
    }

    public void onDisable() {
        mc.player.noClip = false;
    }
}
