package me.darki.konas.module.modules.exploit;

import cookiedragon.eventsystem.Subscriber;
import me.darki.konas.event.events.DamageBlockEvent;
import me.darki.konas.event.events.PacketEvent;
import me.darki.konas.event.events.UpdateWalkingPlayerEvent;
import me.darki.konas.module.Module;
import me.darki.konas.setting.Setting;
import me.darki.konas.util.KonasGlobals;
import me.darki.konas.util.client.BlockUtils;
import me.darki.konas.util.combat.CrystalUtils;
import me.darki.konas.util.interaction.InteractionUtil;
import me.darki.konas.util.timer.Timer;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.init.MobEffects;
import net.minecraft.item.ItemEndCrystal;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.network.play.server.SPacketBlockChange;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;

public class SpeedMine extends Module {

    private Setting<Mode> mode = new Setting<>("Mode", Mode.INSTANT);
    private Setting<InstantMode> instantMode = new Setting<>("Type", InstantMode.MANUAL);
    private Setting<Float> speed = new Setting<>("Speed", 0.8f, 1.0f, 0.0f, 0.1f).withVisibility(() -> mode.getValue() == Mode.PACKET);;
    private Setting<Integer> intensity = new Setting<>("Intensity", 1, 10, 1, 1).withVisibility(() -> mode.getValue() == Mode.VANILLA);
    private Setting<Boolean> fall = new Setting<>("Fall", true).withVisibility(() -> mode.getValue() != Mode.INSTANT);
    private Setting<Boolean> rotate = new Setting<>("Rotate", true).withVisibility(() -> mode.getValue() == Mode.INSTANT);
    private Setting<Boolean> predict = new Setting<>("Predict", true).withVisibility(() -> mode.getValue() == Mode.INSTANT && instantMode.getValue() == InstantMode.AUTOMATIC);
    private Setting<Boolean> safe = new Setting<>("Others", false).withVisibility(() -> mode.getValue() == Mode.INSTANT && instantMode.getValue() == InstantMode.AUTOMATIC);
    private Setting<Boolean> noAnim = new Setting<>("NoAnim", false).withVisibility(() -> mode.getValue() == Mode.INSTANT);
    private Setting<Boolean> strict = new Setting<>("Strict", false).withVisibility(() -> mode.getValue() == Mode.INSTANT);
    private Setting<Boolean> limit = new Setting<>("Limit", false).withVisibility(() -> mode.getValue() == Mode.INSTANT);
    private Setting<Boolean> direction = new Setting<>("Direction", false).withVisibility(() -> mode.getValue() == Mode.INSTANT);
    private Setting<Boolean> crystals = new Setting<>("Crystals", false).withVisibility(() -> mode.getValue() == Mode.INSTANT && instantMode.getValue() == InstantMode.AUTOMATIC);
    private Setting<Float> delay = new Setting<>("Delay", 1.0F, 5F, 0.0F, 0.1F).withVisibility(() -> mode.getValue() == Mode.INSTANT && instantMode.getValue() == InstantMode.AUTOMATIC);

    private enum Mode {
        VANILLA, PACKET, INSTANT
    }

    private enum InstantMode {
        MANUAL, AUTOMATIC
    }

    public SpeedMine() {
        super("SpeedMine", Category.EXPLOIT, "FastMine", "FakeHaste", "InstantMine", "InstantBreak");
    }

    private Timer replaceTimer = new Timer();
    private boolean isReplacing = false;
    private boolean isMining = false;
    private BlockPos lastPos = null;
    private EnumFacing lastFacing = null;
    private Timer rotateTimer = new Timer();
    private int instantTime = 2000;

    public void onEnable() {
        isReplacing = false;
        isMining = false;
        lastPos = null;
        lastFacing = null;
        instantTime = 2000;
    }

    @Subscriber
    public void onDamageBlock(DamageBlockEvent event) {

        if(mc.player == null || mc.world == null) return;

        if(fall.getValue() && mc.player.onGround && mode.getValue() != Mode.INSTANT) {
            if(event.getPos().equals(mc.player.getPosition().down())) {
                mc.player.motionY -= 1.0D;
            }
        }

        switch (mode.getValue()) {
            case VANILLA:
                event.setBlockHitDelay(0);
                mc.player.addPotionEffect(new PotionEffect(MobEffects.HASTE, 69, intensity.getValue(), true, false));
                break;
            case PACKET:
                IBlockState state = mc.world.getBlockState(event.getPos());
                if(state.getMaterial() != Material.AIR) {
                    event.setCurBlockDamageMP(event.getCurBlockDamageMP() + state.getPlayerRelativeBlockHardness(mc.player, mc.world, event.getPos()) * speed.getValue());
                    event.setBlockHitDelay(0);
                }
                break;
            case INSTANT:
                mc.player.swingArm(EnumHand.MAIN_HAND);
                if (canBreak(event.getPos())) {
                    rotateTimer.reset();
                    if (instantMode.getValue() == InstantMode.MANUAL && event.getPos().equals(lastPos)) {
                        instantTime = 500;
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace() : EnumFacing.UP));
                    } else {
                        instantTime = 2000;
                        if (strict.getValue()) {
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace() : EnumFacing.UP));
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace().getOpposite() : EnumFacing.DOWN));
                            if (noAnim.getValue()) {
                                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace().getOpposite() : EnumFacing.DOWN));
                            }
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace() : EnumFacing.UP));
                        } else {
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace() : EnumFacing.UP));
                            if (noAnim.getValue()) {
                                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace() : EnumFacing.UP));
                            }
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getPos(), direction.getValue() ? event.getFace() : EnumFacing.UP));
                        }
                    }
                    lastPos = event.getPos();
                    lastFacing = event.getFace();
                    event.setCancelled(true);
                }
                break;
        }
    }

    public boolean isOffhand() {
        return mc.player.getHeldItemOffhand().getItem() == Items.END_CRYSTAL;
    }

    @Subscriber(priority = 10)
    public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent.Pre event) {
        if (isReplacing && lastPos != null && lastFacing != null && mode.getValue() == Mode.INSTANT && instantMode.getValue() == InstantMode.AUTOMATIC) {
            if (replaceTimer.hasPassed(100F * delay.getValue())) {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                if (crystals.getValue()) {
                    int originalSlot = mc.player.inventory.currentItem;
                    if (!isOffhand()) {
                        int crystalSlot = CrystalUtils.getCrystalSlot();

                        if (crystalSlot != -1 && mc.player.inventory.currentItem != crystalSlot) {
                            mc.player.inventory.currentItem = crystalSlot;
                            mc.player.connection.sendPacket(new CPacketHeldItemChange(crystalSlot));
                        }
                    }
                    if (isOffhand() || (mc.player.inventory.getCurrentItem() != null && mc.player.inventory.getCurrentItem().getItem() instanceof ItemEndCrystal)) {
                        BlockUtils.rightClickBlock(lastPos, mc.player.getPositionVector().add(0, mc.player.getEyeHeight(), 0), isOffhand() ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND, rayTracePlace(lastPos), true);
                    }
                    if (mc.player.inventory.currentItem != originalSlot) {
                        mc.player.inventory.currentItem = originalSlot;
                        mc.player.connection.sendPacket(new CPacketHeldItemChange(originalSlot));
                    }
                }
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, lastPos, direction.getValue() ? lastFacing : EnumFacing.UP));
                if (limit.getValue()) {
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, lastPos, direction.getValue() ? lastFacing.getOpposite() : EnumFacing.DOWN));
                }
                isReplacing = false;
            }
        }

        if (event.isCancelled() || !InteractionUtil.canPlaceNormally()) return;

        if (lastPos != null && lastFacing != null && !rotateTimer.hasPassed(3500) && rotate.getValue()) {
            KonasGlobals.INSTANCE.rotationManager.lookAtVec3d(new Vec3d(lastPos.getX() + 0.5 + lastFacing.getDirectionVec().getX() * 0.5,
                    lastPos.getY() + 0.5 + lastFacing.getDirectionVec().getY() * 0.5,
                    lastPos.getZ() + 0.5 + lastFacing.getDirectionVec().getZ() * 0.5));
        }
    }

    private EnumFacing rayTracePlace(BlockPos pos) {
        for (EnumFacing enumFacing : EnumFacing.values()) {
            RayTraceResult rayTraceResult = mc.world.rayTraceBlocks(new Vec3d(mc.player.posX, mc.player.posY + mc.player.getEyeHeight(), mc.player.posZ), new Vec3d(pos.getX() + 0.5 + enumFacing.getDirectionVec().getX() * 1.0 / 2.0,
                    pos.getY() + 0.5 + enumFacing.getDirectionVec().getY() * 1.0 / 2.0,
                    pos.getZ() + 0.5 + enumFacing.getDirectionVec().getZ() * 1.0 / 2.0), false, true, false);
            if (rayTraceResult != null && rayTraceResult.typeOfHit.equals(RayTraceResult.Type.BLOCK) && rayTraceResult.getBlockPos().equals(pos)) {
               return enumFacing;
            }
        }
        if ((double) pos.getY() > mc.player.posY + (double) mc.player.getEyeHeight()) {
            return EnumFacing.DOWN;
        }
       return EnumFacing.UP;
    }

    @Subscriber
    public void onPacketSend(PacketEvent.Send event) {
        if (mode.getValue() != Mode.INSTANT) return;
        if (predict.getValue() && instantMode.getValue() == InstantMode.AUTOMATIC) {
            if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock) {
                if (((CPacketPlayerTryUseItemOnBlock) event.getPacket()).getPos().offset(((CPacketPlayerTryUseItemOnBlock) event.getPacket()).getDirection()).equals(lastPos)) {
                    isReplacing = true;
                    replaceTimer.reset();
                }
            }
        }
    }

    @Subscriber
    public void onPacketReceive(PacketEvent.Receive event) {
        if (mode.getValue() != Mode.INSTANT) return;
        if (!predict.getValue() && instantMode.getValue() == InstantMode.AUTOMATIC) {
            if (event.getPacket() instanceof SPacketBlockChange) {
                if (((SPacketBlockChange) event.getPacket()).getBlockPosition().equals(lastPos) && ((SPacketBlockChange) event.getPacket()).getBlockState().getBlock() != Blocks.AIR && mc.player.getDistance(((SPacketBlockChange) event.getPacket()).getBlockPosition().getX() + 0.5, ((SPacketBlockChange) event.getPacket()).getBlockPosition().getY() + 0.5, ((SPacketBlockChange) event.getPacket()).getBlockPosition().getZ() + 0.5) < 6) {
                    if (!safe.getValue() || !(((SPacketBlockChange) event.getPacket()).getBlockState().getBlock().equals(mc.world.getBlockState(((SPacketBlockChange) event.getPacket()).getBlockPosition()).getBlock()))) {
                        isReplacing = true;
                        replaceTimer.reset();
                    }
                }
            }
        }
    }

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        return blockState.getBlockHardness(mc.world, pos) != -1;
    }

    @Override
    public void onDisable() {
        if(mode.getValue() == Mode.VANILLA) {
            mc.player.removePotionEffect(MobEffects.HASTE);
        }
    }


}
