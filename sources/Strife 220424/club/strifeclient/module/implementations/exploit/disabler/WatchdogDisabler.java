package club.strifeclient.module.implementations.exploit.disabler;

import best.azura.eventbus.handler.EventHandler;
import best.azura.eventbus.handler.Listener;
import club.strifeclient.event.implementations.networking.PacketInboundEvent;
import club.strifeclient.event.implementations.networking.PacketOutboundEvent;
import club.strifeclient.event.implementations.player.MotionEvent;
import club.strifeclient.event.implementations.world.LoadWorldEvent;
import club.strifeclient.module.implementations.exploit.Disabler;
import club.strifeclient.setting.Mode;
import club.strifeclient.util.networking.PacketUtil;
import club.strifeclient.util.player.ChatUtil;
import club.strifeclient.util.system.Stopwatch;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;
import net.minecraft.network.play.client.C17PacketCustomPayload;
import net.minecraft.network.play.server.S07PacketRespawn;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;

import java.util.ArrayDeque;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicInteger;

public final class WatchdogDisabler extends Mode<Disabler.DisablerMode> {
    @Override
    public Disabler.DisablerMode getRepresentation() {
        return Disabler.DisablerMode.WATCHDOG;
    }

    private final Queue<TimestampedPacket> blacklistedPositions = new ConcurrentLinkedQueue<>();
    private final Queue<Packet<?>> transactionQueue = new ArrayDeque<>();
    private final Stopwatch positionResetTimer = new Stopwatch();
    private final Stopwatch transactionTimer = new Stopwatch();

    private long balance;

    @EventHandler
    private final Listener<MotionEvent> motionEventListener = event -> {
        final float currentPing = mc.getCurrentServerData() == null ? 0 : mc.getCurrentServerData().pingToServer;
        if (this.transactionTimer.hasElapsed(780L + balance)) {
            if(!this.transactionQueue.isEmpty()) {
                final AtomicInteger i = new AtomicInteger();
                transactionQueue.forEach((transaction) -> {
                    PacketUtil.sendPacketNoEvent(transaction);
                    i.getAndIncrement();
                    if(i.get() == transactionQueue.size())
                        this.transactionTimer.reset();
                });
                transactionQueue.clear();
            }
        }
        for (final TimestampedPacket timestampedPacket : this.blacklistedPositions) {
            if (timestampedPacket.getTimestamp() + 410 <= System.currentTimeMillis()) {
                ChatUtil.sendMessageWithPrefix("Compensated");
                final TimestampedPacket position = this.blacklistedPositions.poll();
                PacketUtil.sendPacket(position.getPacket());
                this.balance -= 25L;
            }
        }
    };

    @EventHandler
    private final Listener<PacketOutboundEvent> packetOutboundEventListener = e -> {
        if (e.getPacket() instanceof C17PacketCustomPayload) {
            e.setCancelled(true);
        }

        if (e.getPacket() instanceof C03PacketPlayer) {
            final C03PacketPlayer position = e.getPacket();
            for (final TimestampedPacket packet : this.blacklistedPositions) {
                final C03PacketPlayer cachedPosition = (C03PacketPlayer) packet.getPacket();
                if (cachedPosition.getPositionX() == position.getPositionX() && cachedPosition.getPositionY() == position.getPositionY() && cachedPosition.getPositionZ() == position.getPositionZ()) {
                    ChatUtil.sendMessageWithPrefix("Blocked awaiting packet");
                    e.setCancelled(true);
                    break;
                }
            }
        }

        if (e.getPacket() instanceof C0FPacketConfirmTransaction || e.getPacket() instanceof C00PacketKeepAlive) {
            this.transactionQueue.add(e.getPacket());
            e.setCancelled(true);
        }
    };

    @EventHandler
    private final Listener<LoadWorldEvent> worldEventListener = e -> {
    };

    @EventHandler
    private final Listener<PacketInboundEvent> packetInboundEventListener = e -> {
        if (e.getPacket() instanceof S08PacketPlayerPosLook) {
            if (positionResetTimer.hasElapsed(670L)) {
                final S08PacketPlayerPosLook s08 = e.getPacket();
                this.blacklistedPositions.add(new TimestampedPacket(System.currentTimeMillis(), new C03PacketPlayer.C06PacketPlayerPosLook(s08.getX(), s08.getY(), s08.getZ(), s08.getYaw(), s08.getPitch(), true)));
                this.balance += 25L;
                e.setCancelled(true);
                this.positionResetTimer.reset();
            }
        }

        if (e.getPacket() instanceof S07PacketRespawn) {
            this.balance = 0;
            this.positionResetTimer.reset();
            this.transactionQueue.clear();
            this.blacklistedPositions.clear();
            this.transactionTimer.reset();
        }
    };

    public static final class TimestampedPacket {
        private final long timestamp;
        private final Packet<?> packet;

        public TimestampedPacket(final long timestamp, final Packet<?> packet) {
            this.timestamp = timestamp;
            this.packet = packet;
        }

        public long getTimestamp() {
            return timestamp;
        }

        public Packet<?> getPacket() {
            return packet;
        }
    }
}